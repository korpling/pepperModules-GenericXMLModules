<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <info>
        <title>GenericXMLModules</title>
        <subtitle>User's Guide</subtitle>
        <authorgroup>
            <author>
                <personname>
                    <firstname>Florian</firstname>
                    <surname>Zipser</surname>
                </personname>
                <email>saltnpepper@lists.hu-berlin.de</email>
            </author>
            <author>
                <orgname xml:id="org1">INRIA</orgname>
            </author>
            <author>
                <orgname xml:id="org2">SFB 632 Information Structure / D1 Linguistic
                    Database</orgname>
            </author>
            <author>
                <orgname xml:id="org3">Humboldt-Universität zu Berlin</orgname>
            </author>
            <author>
                <orgname xml:id="org4">Universität Potsdam</orgname>
            </author>
        </authorgroup>
        <copyright>
            <year>2012</year>
            <holder><xref linkend="org1"/>, <xref linkend="org2"/>, <xref linkend="org3"/>, <xref
                    linkend="org1"/>,<xref linkend="org4"/>, All rights reserved.</holder>
        </copyright>
        <releaseinfo>Version ${project.version}</releaseinfo>
    </info>
    <preface>
        <title>Foreword</title>
        <para>The intention of this document is first to give a guide to the user of how to use the
            here mentioned pepper modules and how to utilize a mapping performed by them. Second
            this document shall give a closer view in the details of such a mapping in a declarative
            way, to give the user a chance to understand how specific data will be mapped by the
            presented pepper modules.</para>
    </preface>
    <chapter>
        <title>Overview</title>
        <para>This project contains the pepper modules listed in <xref linkend="table_overview"/>. A
            single module can be identified via its coordinates (module-name, format-name,
            format-version) also given in <xref linkend="table_overview"/>. You can use these
            coordinates in a pepper workflow description file to identify the modules in a pepper
            conversion process. A description of how to model a workfloe description file can be
            found under https://korpling.german.hu-berlin.de/saltnpepper/.</para>
        <table xml:id="table_overview" frame="all">
            <title>pepper modules contained in this project</title>
            <tgroup cols="3" align="left" colsep="1" rowsep="1">
                <thead>
                    <row>
                        <entry>Name of pepper module</entry>
                        <entry>Type of pepper module</entry>
                        <entry>Format (if module is im- or exporter)</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry><xref linkend="genericXml_importer"
                                endterm="genericXml_importer_name"/></entry>
                        <entry>importer</entry>
                        <entry>1.0</entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
    </chapter>
    <!-- no changes so far
    <chapter xml:id="changes">
        <title>Changes</title>
        <para> This chapter contains the changes in version ${project.version} compared to the
        previous version. </para>
        <section>
            <title><xref linkend="genericXml_importer_name"/></title>
        <itemizedlist spacing="compact">
            <listitem>
                <para>If a {@link BasicTranscription} object contains the not empty attribute
                    referencedFile, a {@link SAudioDataSource} will be created containing the given
                    {@link URI}. all @time attributes will be mapped to a SAudioDSRelation, if an
                    event mapped to an SToken only contains sStart or SEnd, only these values will
                    be set (an automatic interpolation can be provided). </para>

            </listitem>
            <listitem>
                <para>in case of some tli objects are not covered by event objects of the
                    token-tier, artificial events will be created, including the primary text "" for
                    instance </para>
                <table>
                    <title/>
                    <tgroup cols="3" align="left" colsep="1" rowsep="1">
                        <tbody>
                            <row>
                                <entry/>
                                <entry>token</entry>
                                <entry/>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <para>will be enhanced to</para>
                <table>
                    <title/>
                    <tgroup cols="3" align="left" colsep="1" rowsep="1">
                        <tbody>
                            <row>
                                <entry>EMPTY_STRING</entry>
                                <entry>token</entry>
                                <entry>EMPTY_STRING</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </listitem>
        </itemizedlist>
        </section>
    </chapter>
    -->
    <chapter xml:id="genericXml_importer">
        <title xml:id="genericXml_importer_name">GenericXMLImporter</title>
        <para>Imports data coming from any XML file to a Salt model in a customizable but generic
            way. This importer provides a wide range of customizing possibilities via the here
            described set of Properties. Before we talk about the possibility of customizing the
            mapping, we describe the general and default mapping from an xml file to a Salt
            model.</para>
        <sect1>
            <title>Mapping to Salt</title>
            <para>The GenericXMLImporter maps elemtent-nodes, text-nodes and attribute-nodes to Salt
                model objects. Comment-nodes, processing-instruction-nodes etc. will be ignored and
                not be mapped. </para>
            <para>The textual value of all text-nodes of the xml document will be concatenated to
                one single primary text. This primary text is stored in a
                    <classname>STextualDS</classname> object and can be accessed via the method
                    <methodname>STextualDS.getSText()</methodname>. Each element-node containing a
                primary text and no further element-nodes (so called terminal-node) is mapped to a
                    <classname>SToken</classname> object overlapping the part of the primary data
                given by the contained text-node. To realize the offset to the start and end
                position of the overlapping text, a <classname>STextualRelation</classname> is
                created connecting the <classname>STextualDS</classname> and the
                    <classname>SToken</classname> object.</para>
            <para>The following xml fragment
                <programlisting>&lt;a>This is&lt;/a>&lt;b> a sample text&lt;/a></programlisting> is
                mapped to a <classname>STexualDS</classname> object having the
                    <varname>sText</varname> "This is a sample text" and two
                    <classname>SToken</classname> objects, one overlapping the text "This is" and
                one overlaping the text " a sample text". </para>
            <note>
                <para>The importer does not take care about the given tokenization and does not
                    retokenize it.</para>
            </note>
            <para>A element-node not containing further element-nodes (so called complex-node) is
                mapped to a <classname>SStructure</classname> object in the Salt model. Since
                    <classname>SStructure</classname> objects in Salt represent a hierarchical
                structure, a <classname>SStructure</classname> object is connected to
                    <classname>SNode</classname> objects corresponding to the element-nodes in the
                first level of the subtree of the element-node.</para>
            <para>The following xml fragment
                <programlisting>&lt;a>&lt;b>a sample&lt;/b>&lt;/a></programlisting> is mapped to a
                    <classname>SToken</classname> (corresponding to the element-node &lt;a>) object
                overlapping the primary text "a sample" and a <classname>SStructure</classname>
                (corresponding to the element-node &lt;b>) object dominating the SToken object. Both
                nodes are conneted with a <classname>SDominanceRelation</classname> having the
                    <classname>SStructure</classname> object as source and the
                    <classname>SToken</classname> object as target. Since SStrcuture objects are
                used for hierarchies, the same goes for a element-node containing another element
                node. </para>
            <para>The following xml fragment
                <programlisting>&lt;a>&lt;b>...&lt;/b>&lt;/a></programlisting>is mapped to a
                    <classname>SStructure</classname> object representing the element-node &lt;a>
                and dominating a further <classname>SStructure</classname> object representing the
                element-node &lt;b>. </para>
            <para>In many xml formats element-nodes can have further element-nodes and text-nodes in
                the first level of their subtree as well. These kind of nodes are often called mixed
                nodes (for nodes having a mixed content). These kind of nodes are mapped to a
                    <classname>SStructure</classname> object in Salt. The element-nodes contained
                their subtree are mapped to either <classname>SToken</classname> objects or
                    <classname>SStructure</classname> objects, depending on their contant. For a
                text-node, an artificial <classname>SToken</classname> object is created and added
                to the subtree of the <classname>SStructure</classname> object in Salt.</para>
            <para>The following xml fragment
                <programlisting>&lt;a>This is &lt;b>a sample&lt;/b> text&lt;/a></programlisting>is
                mapped to three <classname>SToken</classname> objects t1 overlapping the text "This
                is ", t2 overlapping the text "a sample" and t3 overlapping the text " text".
                Because the <classname>SToken</classname> object t2 is the only one having an
                existing correspondance to a terminal-node, two artificial
                    <classname>SToken</classname> objects t1 and t3 are created. The complex-node
                &lt;a> is mapped to a <classname>SStructure</classname> object dominating the three
                    <classname>SToken</classname> objects in the order t1, t2 and t3. This mechanism
                is recursive and will also work for the following xml
                fragment<programlisting>&lt;a>This is &lt;b>&lt;c>a sample&lt;/c>&lt;/b> text&lt;/a></programlisting>,
                for which a further <classname>SStructure</classname> object corresponding the
                complex-node &lt;b> is created and is dominating the <classname>SToken</classname>
                object corresponding to the terminal-node &lt;c>. </para>
            <para>Attribute-nodes are mapped to <classname>SAnnotation</classname> objects, having
                the attribute-name as <varname>SName</varname> and the attribute-value as
                    <varname>SValue</varname>. Such an <classname>SAnnotation</classname> object is
                added to the list of <classname>SAnnotation</classname> of a container
                    <classname>SNode</classname> object. </para>
            <para>The following xml fragment
                <programlisting>&lt;a att="value">a sample&lt;/a></programlisting> is mapped to a
                    <classname>SToken</classname> overlapping the text "a sample" and containing a
                    <classname>SAnnotation</classname> object having the <varname>SName</varname>
                "att" and the <varname>SValue</varname> "value". The same goes for complex-nodes and
                mixed-nodes.</para>
        </sect1>
        <sect1>
            <title>Properties</title>
            <para> The table <xref linkend="importer_prop_overview"/> contains an overview of all
                usable properties to customize the behaviour of this pepper module. The following
                section contains a brief description to each single property and describes the
                resulting differences in the mapping to the salt model.</para>
            <para>Some of the here described properties use for their values a small subset of the
                XPath language for addressing nodes in the xml document to import. This subset
                contains possibilities to address element-nodes, text-nodes and attribute-nodes in
                just a simple way via following the descendant axis. The descendant axis can only be
                used by the shortcut syntax represented by a '/' for a direct descendant and '//'
                for any descendants. The other axes and predicates as well are not yet supported.
                The following tables show the use of the supported XPath subset.</para>
            <para><table frame="all">
                    <title>support for element-nodes</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                        <colspec colname="c2" colnum="2" colwidth="6.83*"/>
                        <thead>
                            <row>
                                <entry>XPath expression</entry>
                                <entry>description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>//element</entry>
                                <entry>addresses the xml element-node having the name element and
                                    which is the root node</entry>
                            </row>
                            <row>
                                <entry>//element</entry>
                                <entry>addresses the xml element-node having the name element
                                    anywhere in the document</entry>
                            </row>
                            <row>
                                <entry>/father/element</entry>
                                <entry>addresses the xml element-node having the name element and
                                    its subtree, which is a direct descendant of an element-node
                                    having the name father</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <table frame="all">
                    <title>support for attribute-nodes</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                        <colspec colname="c2" colnum="2" colwidth="6.83*"/>
                        <thead>
                            <row>
                                <entry>XPath expression</entry>
                                <entry>description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>//@attribute</entry>
                                <entry>addresses the xml attribute-node having the name attribute
                                    anywhere in the document</entry>
                            </row>
                            <row>
                                <entry>//element/@attribute</entry>
                                <entry>addresses the xml attribute-node having the name attribute
                                    and belongs to the xml element-node having the name element
                                    which is a direct descendant of an element-node named
                                    father</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <table frame="all">
                    <title>support for text-nodes</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                        <colspec colname="c2" colnum="2" colwidth="6.83*"/>
                        <thead>
                            <row>
                                <entry>XPath expression</entry>
                                <entry>description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>//text()</entry>
                                <entry>addresses every xml text-node anywhere in the
                                    document</entry>
                            </row>
                            <row>
                                <entry>//element/text()</entry>
                                <entry>addresses every xml text-node belonging to the xml
                                    element-node having the name element which is a direct
                                    descendant of an element-node named father</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table> For some properties it is possible, to not only address one element-node,
                text-node or attribute-node, but to address a set of nodes. For such cases, you can
                separate XPath expressions by using the ',' character. For instance:
                <programlisting>//element1/text(), //element2/text()</programlisting> and so on. The
                size of such a set is unbound. </para>
            <table xml:id="importer_prop_overview" frame="all">
                <title>properties to customize importer behaviour</title>
                <tgroup cols="4" align="left" colsep="1" rowsep="1">
                    <colspec colnum="1" colname="c1" colwidth="2.16*"/>
                    <colspec colnum="2" colname="c2" colwidth="2.0*"/>
                    <colspec colnum="3" colname="c3" colwidth="1.52*"/>
                    <colspec colnum="4" colname="c4" colwidth="1.0*"/>
                    <thead>
                        <row>
                            <entry>Name of property</entry>
                            <entry>Type of property</entry>
                            <entry>optional/ mandatory</entry>
                            <entry>default value</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><xref linkend="prop_prop1" endterm="importer_prop1_title"
                                /></entry>
                            <entry>XPath expression of described subset</entry>
                            <entry>optional</entry>
                            <entry>--</entry>
                        </row>
                        <row>
                            <entry><xref linkend="prop_prop2" endterm="importer_prop2_title"
                                /></entry>
                            <entry>XPath expression of described subset</entry>
                            <entry>optional</entry>
                            <entry>--</entry>
                        </row>
                        <row>
                            <entry><xref linkend="prop_prop3" endterm="importer_prop3_title"
                                /></entry>
                            <entry>XPath expression of described subset</entry>
                            <entry>optional</entry>
                            <entry>--</entry>
                        </row>
                        <row>
                            <entry><xref linkend="prop_prop4" endterm="importer_prop4_title"
                                /></entry>
                            <entry>Boolean</entry>
                            <entry>optional</entry>
                            <entry>false</entry>
                        </row>
                        <row>
                            <entry><xref linkend="prop_prop5" endterm="importer_prop5_title"
                                /></entry>
                            <entry>XPath expression of described subset</entry>
                            <entry>optional</entry>
                            <entry>--</entry>
                        </row>
                        <row>
                            <entry><xref linkend="prop_prop6" endterm="importer_prop6_title"
                                /></entry>
                            <entry>XPath expression of described subset</entry>
                            <entry>optional</entry>
                            <entry>--</entry>
                        </row>
                        <row>
                            <entry><xref linkend="prop_prop7" endterm="importer_prop7_title"
                                /></entry>
                            <entry>Boolean</entry>
                            <entry>optional</entry>
                            <entry>false</entry>
                        </row>
                        <row>
                            <entry><xref linkend="prop_prop8" endterm="importer_prop8_title"
                                /></entry>
                            <entry>XPath expression of described subset</entry>
                            <entry>optional</entry>
                            <entry>--</entry>
                        </row>
                        <row>
                            <entry><xref linkend="prop_prop8" endterm="importer_prop8_title"
                                /></entry>
                            <entry>String</entry>
                            <entry>optional</entry>
                            <entry>xml</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <sect2 xml:id="prop_prop1">
                <title xml:id="importer_prop1_title">genericXml.importer.ignoreList</title>
                <para>The ignore list is a list of nodes (element-nodes , attribute-nodes and
                    text-nodes) which are ignored for the mapping to a Salt model. Imagine for
                    instance the follwing xml fragment
                    <programlisting>&lt;a>&lt;b>&lt;/b>&lt;/a></programlisting>and the property
                    value of ignore-list //b. This will result, that the element-node &lt;b> will
                    completle be ignored. <note>
                        <para>If an element-node is part of the ignore list, its subtree, its
                            attribute-nodes and contained text-nodes will also be ignored. For
                            instance remember the last example fragment and the property value of
                            //a. This will result, that neither the element-node &lt;a> nor the
                            element-node &lt;b> are mapped.</para>
                    </note></para>
                <para>Here we give a sample of the usage of the ignore list:
                    <programlisting>genericXml.importer.ignoreList= /a/b, //c</programlisting></para>
            </sect2>
            <sect2 xml:id="prop_prop2">
                <title xml:id="importer_prop2_title">genericXml.importer.asSSpan</title>
                <para>In case of you don't want to map an element node to a
                        <classname>SStructure</classname> object, you can also map defined
                    element-nodes to an <classname>SSpan</classname> object.
                        <classname>SSpan</classname> in contrast to
                        <classname>SStructure</classname> objects are not hierarchical and are used
                    to create span-like structures, similar to cells in a table.</para>
                <para>Here we give a sample of the usage of the ignore list:
                    <programlisting>genericXml.importer.asSSpans= //element1, //father/element2</programlisting></para>
            </sect2>
            <sect2 xml:id="prop_prop3">
                <title xml:id="importer_prop3_title">genericXml.importer.prefixSAnnotation</title>
                <para>In general the <varname>SName</varname> of a
                        <classname>SAnnotation</classname> is given by the name of the
                    attribute-node given in the xml document. sometimes it might be necessary, to
                    remember the name of the element-node containing the attribute-node. In such
                    cases, you can set this property to prefix the <classname>SName</classname> of
                    the <classname>SAnnotation</classname> with the name of the surrounding
                    element-node. The following xml fragment
                    <programlisting>&lt;a att="value"/></programlisting>will is mapped to a
                        <classname>SAnnotation</classname> object having the
                        <varname>SName</varname> 'att'. When setting the property as shown in the
                    following sample,
                    <programlisting>genericXml.importer.prefixSAnnotation=//a/@att</programlisting></para>
            </sect2>
            <sect2 xml:id="prop_prop4">
                <title xml:id="importer_prop4_title">genericXml.importer.artificialSStruct</title>
                <para>In general a terminal-node is mapped to a <classname>SToken</classname>
                    object. This is necessary, because in Salt only <classname>SToken</classname>
                    objects can overlap parts of the primary data (given by
                        <classname>STextualDS</classname> objects). Sometimes, one may want to map
                    the terminal-node also to a <classname>SSpan</classname> or
                        <classname>SStructure</classname> node. Using this property will result in
                    an artificial node dominating or spanning the <classname>SToken</classname>
                    object. </para>
                <para>The xml fragment <programlisting>&lt;a>a sample&lt;/a></programlisting> when
                    using the property
                    <programlisting>genericXml.importer.artificialSStruct= true</programlisting> the
                    mapping will create a <classname>SToken</classname> object overlaping the the
                    primary data "a sample" and a <classname>SStructure</classname> object
                    dominating the <classname>SToken</classname> object.</para>
                <note>
                    <para>When using this flag, an artificial SSpan can be created instead of an
                        SStructure object, when adding an XPath expressiion addressing the
                        terminal-node to the set of expressions of the property <xref
                            linkend="prop_prop2" endterm="importer_prop2_title"/></para>
                </note>
            </sect2>
            <sect2 xml:id="prop_prop5">
                <title xml:id="importer_prop5_title">genericXml.importer.sMetaAnnotation</title>
                <para>Normaly a attribute-node is mapped to <classname>SAnnotation</classname>
                    object. But sometimes you may want to map it to a
                        <classname>SMetaAnnotation</classname> object instead. A
                        <classname>SMetaAnnotation</classname> in Salt marks an attribute-value pair
                    to be not directly a linguistic annotation, and therefore not processed or
                    exported as one. Often such annotations are used to mark the annotator of an
                    annotation, or a probaility of an annotation and so on. </para>
                <para>The xml fragment <programlisting>&lt;a att="value"/></programlisting> using
                    the property
                    <programlisting>genericXml.importer.sMetaAnnotation=//a/@att</programlisting>
                    will result in a a <classname>SNode</classname> object representing the
                    element-node &lt;a> having a <classname>SMetaAnnotation</classname> object with
                    the <varname>SName</varname> 'att' and the <varname>SValue</varname>
                    "value".</para>
            </sect2>
            <sect2 xml:id="prop_prop6">
                <title xml:id="importer_prop6_title"
                    >genericXml.importer.sMetaAnnotation.sDocument</title>
                <para>Xml documents often also contain sections for meta-data of the entire
                    document, for instance the name of the author of the document, the year of
                    creation, or the mothers tongue of the author etc.. For dealing with such a
                    case, you can use this flag, to mark an element or an entire subtree as a
                    meta-data section. Each attribute-node of such an element or subtree is mapped
                    to a <classname>SMetaAnnotation</classname> object having its name as
                        <varname>SName</varname> and its value as <varname>SValue</varname> and is
                    added to the list of meta-data of the <classname>SDocument</classname>. </para>
                <para>The following xml fragment
                    <programlisting>&lt;a att_2="value">&lt;b att_1="value"/>&lt;/a></programlisting>
                    when using the
                    property<programlisting>genericXml.importer.sMetaAnnotation.sDocument=//a</programlisting>
                    results in a <classname>SDocument</classname> object containing two
                        <classname>SMetaAnnotation</classname> objects having the
                        <classname>SName</classname> 'att_1' and the <varname>SValue</varname>
                    'value' or 'att_2' and 'value'.<note>
                        <para>When more than one attribute-nodes have the same name, the mapper will
                            add an '_' and a number to their name, because in Salt an
                                <classname>SDocument</classname> cannot have two
                                <classname>SMetaAnnotation</classname> objects having the same
                                <varname>SName</varname>. To avoid this behaviour, you can use the
                            property <xref linkend="prop_prop3" endterm="importer_prop3_title"/> to
                            concatenate the name of the element-node with the name of the
                            attribute-node.</para>
                    </note>
                </para>
                <para>To interprete an entire subtree of an xml element as a meta-data containing
                    subtree, use the wildcard notation at the end of your XPath expression.</para>
                <para>The following xml fragment
                    <programlisting>&lt;a>
    &lt;b att_1="value">
        &lt;c att2="value"/>
    &lt;/b>
    &lt;d>a sample text&lt;/d>
&lt;/a></programlisting>
                    when using the
                    property<programlisting>genericXml.importer.sMetaAnnotation.sDocument=//b, //b//</programlisting>
                    results in one <classname>SToken</classname> object overlapping the primary text
                    'a sample text' being dominated by a <classname>SStructure</classname> object
                    corresponing to element &lt;a>. The xml-element &lt;b> and its entire subtree is
                    interpreted as meta-data for the <classname>SDocument</classname> object.</para>
            </sect2>
            <sect2 xml:id="prop_prop7">
                <title xml:id="importer_prop7_title">genericXml.importer.textOnly</title>
                <para>When using this flag, only the text is imported as primary data. That means
                    all text-nodes will be concatenated to a single text. A
                        <classname>STextualDS</classname> object is created and its
                        <varname>SText</varname> will be set to the concatenated text.</para>
            </sect2>
            <sect2 xml:id="prop_prop8">
                <title xml:id="importer_prop8_title">genericXml.importer.sLayer</title>
                <para>In Salt, <classname>SLayer</classname>s are important to separate several
                    kinds of linguistic annotations. For instance to separate a syntax analysis from
                    a dialogue analysis etc.. To identify such a layer in a xml file you can use
                    this property. An addressed element-node is mapped to a
                        <classname>SLayer</classname> object, its attribute-nodes are mapped to
                        <classname>SAnnotation</classname> objects. In a lot of cases an XPath
                    expression addresses a set of element-nodes. All these nodes having the same
                    name, are mapped to the same <classname>SLayer</classname> object. All
                    element-nodes of the the subtree of an addressed element-node are added to the
                    corresponding <classname>SLayer</classname> object. Layers are recursive
                    objects, therefore layers can contain other layers.</para>
                <para>The following xml fragment
                    <programlisting>&lt;a att="value">&lt;b>a sample &lt;c>text&lt;/c>&lt;/b>&lt;/a></programlisting>
                    with the use of the property
                    <programlisting>genericXml.importer.sLayer=//a, //c</programlisting> results in
                    two <classname>SToken</classname> t1 and t2 objects, overlapping the text 'a
                    sample' (t1) and 'text' (2). The <classname>SToken</classname> object t2 is part
                    of a created <classname>SLayer</classname> object l1 corresponding to the
                    element-node &lt;c>. A <classname>SStructure</classname> object is created
                    containing the <classname>SToken</classname> objects t1 and t2. This
                        <classname>SStructure</classname> object and the
                        <classname>SToken</classname> t1 are not part of the created layer. A second
                    layer l2 is created for the element-node &lt;a>. An
                        <classname>SAnnotation</classname> object having the
                        <varname>SName</varname> 'att' and the <varname>SValue</varname> 'value' is
                    added to l2. All created <classname>SNode</classname> objects and the SLayer
                    object l2 are contained in the layer l2.</para>
            </sect2>
            <sect2 xml:id="prop_prop9">
                <title xml:id="importer_prop10_title">genericXml.importer.file.endings</title>
                <para>Determines a list, containing the file endings, which files are imported. If
                    you want to import all contained files no matter to their ending, add the string
                    'ALL' to the list. If you want a file having a specific ending not to be
                    imported, use the prefix '-'.</para>
            </sect2>
        </sect1>
    </chapter>
</book>
